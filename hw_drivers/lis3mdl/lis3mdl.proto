// Information specific to LIS3MDL Magnetometer
//
// WIP - I am scratchpadding here / I'd like to avoid binding too many hardware
// specifics here. Likely we'll leave most of the specifics in the C++ and
// expose more of the human-decipherable output at a higher "imu" abstraction.
//
// Reference:
// - https://www.pololu.com/file/0J1089/LIS3MDL.pdf
// - https://www.pololu.com/file/0J1090/LIS3MDL-AN4602.pdf
// - //hw_drivers/lis3mdl:README.md

syntax = "proto3";

package hw_drivers.lis3mdl;

// XXX: add nanopb options back
// import "nanopb.proto";


// XXX: Should I define _INVALID at 0 and not tie to bit-mapping?
// enum OperatingMode {
//   OPERATING_MODE_LOW_POWER = 0;
//   OPERATING_MODE_MEDIUM_PERFORMANCE = 1;
//   OPERATING_MODE_HIGH_PERFORMANCE = 2;
//   OPERATING_MODE_ULTRA_HIGH_PERFORMANCE = 3;
// };

// How do we want to configure this magnetometer.
// 
// XXX: Could change this to a desired configuration, and then the instrument
// returns how it's actually able to be configured.
//
// We could also use power draw as a factor in selection.
// Start-up time also factors in here.
message LIS3MDLConfiguration {

  // Whether to enable temperature reading
  // XXX: Maybe just always enable it?
  optional bool temperature_enabled = 1;
  
  // Defines the noise of the signal
  // We won't allow different operating modes by axis, even though we could have
  // a separate one for X/Y and Z
  // There's a specific low power setting as well, we'll choose not to utilize
  // that.
  // optional OperatingMode operating_mode = 2;

  // Perhaps we could define this as allowable_rms_noise in micro-Gauss
  // [   0, 3500) INVALID
  // [3500, 4000) UHP
  // [4000, 4600) HP
  // [4600, 5300) MP
  // [5300, +inf) LP
  // This determines OperatingMode
  optional uint32 allowable_rms_noise_ug = 2;
  
  // Allowable Output Data Rate (mHz):
  // (625, 1,250, 2,500, 5,000, 10,000, 20,000, 40,000, 80,000)
  // Really just base 0.625 and a factor of 2 * 
  // - then we add fast_odr and
  // - LP: 1,000,000
  // - MP:   560,000
  // - HP:   300,000
  // - UHP:  155,000 become valid
  // data rate in milli-hertz
  // XXX: Should I capitalize field names, eg) dB and mHz vs. MHz
  optional uint32 data_rate_millihz = 3;
  
  // Scale and resolution are intrinsically tied
  // Scales available are 4, 8, 12, 16 gauss range
  // XXX: enum or not?
  optional uint32 scale_gauss = 4;
  
  // We could configure big/little endian, but we will allow the firmware to
  // determine the setting it would like to use.
  
  // We could also configure interrupt thresholds and behavior, but we don't
  // support that.
};

message LIS3MDLCommands {
  oneof cmd {
    // XXX: I'm not sure what the difference is
    bool reboot = 1;
    bool soft_reset = 2;
  };
};

message LIS3MDLReading {

  // XXX: fixed repeated or individual fields?
  // XXX: re-evaluate unit
  // - experiment with unit libraries

  // The magnetic strength in micro-Gauss
  // XXX: Causes crash on assignment to a rpc result.
  // repeated sint32 magnetic_strength_ug = 1;  // XXX [(nanopb).max_count = 3, (nanopb).fixed_count = true];
  optional sint32 magnetic_strength_x_ug = 5;
  optional sint32 magnetic_strength_y_ug = 6;
  optional sint32 magnetic_strength_z_ug = 7;

  // Temperature in tenths of a degree celcius (we get 1/8 C resolution).
  optional sint32 temperature_dc = 2;

  // Whether the data we're reading has been updated since our last reading
  optional bool data_fresh = 3;
  // Whether any data was overwritten since our last read
  optional bool data_overrun = 4;
};

// For testing we may want to get a lot of readings
// We could do a repeated LIS3MDLReading or a more efficient structure,
// determine based on total number of reads ...
//
// [ ] Write tooling to describe how this thing'll work
